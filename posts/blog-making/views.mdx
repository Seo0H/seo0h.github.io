---
title: '블로그 조회수 기능 제작기 - 1'
description: '클라이언트 데이터가 따로 존재하는 상황에서 조회수 기능 구현하기'
draft: false
image:
date: 2024-03-04 15:46:22
uuid: fbf28aa8-b8ad-4ab0-a564-7e79ac149feb
---

### 글을 들어가며

오랫만에 글을 쓰네요! 24년을 기념해 제 블로그에 새로운 기능을 추가했는데요, 바로 **조회수 기능**입니다. 동시에 블로그 도메인도 좀 더 깔끔하게 바꿨습니다. 이번년도의 첫 글로 클라이언트 데이터가 따로 존재하는 상황에서 조회수 기능 구현을 해본 대한 제 경험을 공유하는 글을 써보고자 합니다.

기존 블로그 데이터가 mdx를 이용해 작성되던 상황이었기에 DB와 클라이언트 데이터를 어떻게 위치시키고 동기화해야 할지 고민한 내용을 정리해보고자 했습니다. 그럼 시작해볼까요!

### 방향성

구현하고자 하는 조회수 기능의 로직입니다.

> - **지난 30분간** 해당 글의 조회한 적이
>   - -> **없으면** 조회수가 1올라간다.
>   - -> **있으면** 조회수가 올라가지 않는다.

조회수 기능을 구현하기 위해 생각했던 옵션은 2가지 였습니다.

> 1. **GA** : GA의 조회수를 가져오기
> 2. **DB + Next.js** : Supabase와 Next IRS 기능을 이용해 조회수 정보 구현


![예민하게 수집되는 ga의 조회수 정보](/posts/views/240304-163433.png)

둘 중 좀 리소스가 적게 드는 방법은 1번. **GA의 조회수를 가져오는 방법**이였으나 생각보다, **너무 예민하게 조회수를 수집한다는 단점**이 있었습니다. (screen-view + page-view를 합산한 이벤트라고 하네요.) 따라서 자연스럽게 2번 방법으로 방향성을 잡게 되었습니다.

2번 방법을 구현하기 위해선 크게 4가지의 문제들을 해결해야 했습니다.

> **⚠️ Issues**
> 1. **스키마 구성** : 조회수 정보가 담긴 DB의 스키마를 어떻게 구성 할 것인가?
> 2. **정보 식별 방법** : 클라이언트의 post 정보를 어덯게 DB에 저장하고 식별할 것인가?
> 3. **정합성 유지** : DB와 클라이언트의 post의 데이터의 정합성을 어떻게 유지할 것인가?
> 4. **조회수 로직** : 조회수가 수집되는 예민한 정도를 어떻게 구현할 것인가?

---

### 블로그 포스트에 유니크한 값 부여하기 -> snippets

클라이언트에서 블로그 포스트 정보를 가지고 있었기 때문에 DB의 PK를 어떻게 설정해야 할지 고민이였습니다. 포스트의 제목을 PK로 사용하기에는 변동될 수 있다는 위험이 있고, 그렇다고 바로 당장 작성되어 있는 모든 포스트를 DB로 옮기는 것은 너무나 큰 리소스가 들기 때문에 꺼려지는 방향이였습니다.

따라서, **포스트를 생성할 때 임의의 uuid를 부여해서 pk로 사용**하면 어떨까? 라는 아이디어를 떠올리게 되었고 해당 방식을 기존에 사용하던 **vscode snippets에 통합**하였습니다. mdx의 메타데이터를 기입할 때 사용하던 자동완성 스니펫에 `uuid : $UUID` 를 추가했습니다. 그러면 해당 자동완성을 사용할 때 임의의 uuid 값이 부여되게 됩니다.

```json {8} caption="vscode snippets uuid 적용 예시"
"matter": {
    "scope": "*.mdx",
    "prefix": ["---"],
    "description": "mdx mata-data",
    "body": [
      "---",
     // ... mdx mata data
      "uuid: $UUID",
      "---",
      "",
      "$0"
    ],
    "scope": "md,mdx"
  }
```

<details>
   <summary> **MDX 적용 예시** </summary>
       <div markdown="1">

       ``` mdx {7}
        ---
        title: '블로그 조회수 기능 제작기'
        description: '조회수 기능을 구현하며 배운 정보를 정리하고 공유합니다.'
        draft: false
        image:
        date: 2024-03-04 15:46:22
        uuid: fbf28aa8-b8ad-4ab0-a564-7e79ac149feb
        ---
       ```
       </div>
</details>

---

### Supabase Post 스키마 구성, 테이블 생성

따라서 아래와 같은 Post 테이블의 스키마가 나오게 되었습니다.

![supabase schema](/posts/views/240304-192459.png)


| 속성(attribute) | type      | 설명                          |
| --------------- | :--------- | :---------------------------- |
| id              | text (pk) | 포스트를 식별하는 유니크한 값      |
| title           | text      | 포스트 제목                   |
| views           | int4      | 조회수                        |

---

### 정합성 유지 - 서버와 클라이언트 데이터 비교하기

블로그 글과 DB의 정보를 동기화 해야 했습니다. 정보가 달라질 수 있는 조건은 다음과 같습니다.

> 1. **Insert** : 새로운 글이 추가된 경우
> 2. **Delete** : 글이 삭제된 경우
> 3. **Update** : 글의 제목이 바뀐 경우

**서버 데이터인 조회수와 클라이언트 데이터인 블로그 데이터를 합치는 과정이 필요**했기에 복잡도가 올라갈 것이라 예상이 들어 해당 로직을 **`StaticPostData` singleton class로 분리**해주었습니다. **서버와 클라이언트를 동기화하는 로직을 묶어 `synchronizeServerAndClientPosts` 에서 처리하도록 분리하고 이 부분은 블로그가 정적으로 빌드될 때 계산하도록 `getStaticProps` 부분에서 실행**되도록 했습니다.

(NOTE: post 리소스가 중복되서 메모리에 존재 할 필요가 없기에 singleton class로 구현하였습니다.)

따라서 main page의 `getStaticProps`는 일단 아래와 같은 코드 구조를 가지게 되었습니다.

```tsx
export const getStaticProps = (async () => {
  // StaticPostData getInstance 실행 시 인스턴스를 얻어옵니다.
  // 생성자에서  posts, tages, serverPosts의 초기화가 클라이언트 데이터 기준으로 진행됩니다.
  const staticPost = await StaticPostData.getInstance();
  const { serverPosts, posts, allTags: tags } = staticPost;

 //  Post의 서버 데이터 업데이트 필요 여부를 판단하고,
 // 업데이트가 필요하면 서버 데이터를 클라이언트 데이터 기준으로 업데이트 합니다.
 await staticPost.synchronizeServerAndClientPosts({
    serverPosts,
    clientPosts: posts,
  });

  return {
    props: { posts, tags },
  };
}) satisfies GetStaticProps<{
  posts: Post[];
  tags: string[];
}>;

```
`synchronizeServerAndClientPosts` 내부에서 아래와 같이 상황별 로그가 찍히도록 구성해두었습니다.


| 새로운 포스트 생성                  | 제목 수정                           | 업데이트 불필요                |
| ----------------------------------- | ----------------------------------- | ----------------------------------- |
| ![](/posts/views/240304-200421.png) | ![](/posts/views/240304-200200.png) | ![](/posts/views/240304-200221.png) |

### 조회수 로직 - 세션 또는 쿠키를 이용한 검증

> **⚠️ Issues**
> 1. ~~**스키마 구성** : 조회수 정보가 담긴 DB의 스키마를 어떻게 구성 할 것인가?~~
> 2. ~~**정보 식별 방법** : 클라이언트의 post 정보를 어덯게 DB에 저장하고 식별할 것인가?~~
> 3. ~~**정합성 유지** : DB와 클라이언트의 post의 데이터의 정합성을 어떻게 유지할 것인가?~~
> 4. **조회수 로직** : 조회수가 수집되는 예민한 정도를 어떻게 구현할 것인가?

이제 1~3번 문제들을 해결했습니다. 남은건 4번 **조회수 로직 구현** 문제 입니다.

**'30분간 조회한 유저'를 판단하는 로직을 만들기 위해서는 '30분 간 방문한 유저의 정보' 를 가지고 있는 장치가 필요**합니다. 브라우저의 로컬 또는 세션스토리지는 유저가 직접 삭제할 수 있기에 조회수가 수집되었을때 정보를 신뢰할 수 없습니다.

따라서 **쿠키 또는 세션을 이용해 유저의 방문 여부를 검증**하는 것이 가장 외부 요인에 영향을 덜 받는 방향이라 생각이 들어 해당 방식을 통해 구현하기로 결정했습니다. (혹시 이것보다 더 나은 방식이 있다면 알려주세요! 적극 반영하겠습니다 😃 )

이를 위해서는 **쿠키나 세션을 발행하고 임시 값을 저장해두는 로직을 관리하는 backend 서버가 필요**했는데요, 다음 글에서는 Nest.js, AWS E2C, Docker 를 이용해 간단한 백엔드 서버 구축을 해본 과정에 대해 다뤄보려고 합니다. 읽어주셔서 감사합니다.
